{
  "hash": "ded90da7cbb7a2f0ddb61d19708ebeb3",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Data Wrangling\"\n---\n\n\n# [**Introduction**]{style=\"color: #2C6D26;\"}\n\nData wrangling is the process of transforming raw data into a more organized and structured format, which facilitates improved insights and better decision-making. Imagine your data as a set of puzzle you need to solve, data wrangling is a tool that will significantly help you to organise the data, making it much easier to solve the data puzzles.\n\nThere are six stages involved in data wrangling, they are highlighted below:\n\n1.  **Data Discovery:** Data discovery is the *process of uncovering and exploring valuable insights* within data. This usually involves collecting data from different sources, transforming and merging it, and employing visualization and analytical methods to reveal patterns, trends, and insights. The aim is to make data more accessible and actionable for decision-making, enabling users to grasp complex information and address specific business questions.\n\n    Data discovery is the process that enables users to visually explore data and apply advanced analytics to uncover patterns, gain insights, answer specific questions, and extract value from business information. It involves integrating and transforming data from multiple sources, analyzing data structures, and using visualization techniques to gain insights and extract valuable information.\n\n2.  **Data Structuring:** Data structures are specialized formats for organizing data on a computer to ensure efficient processing, storage, and retrieval. They provide a systematic way to manage information, making it easier to access and use. A data structure is a *method for organizing and managing data*. It helps in gathering different types of data, whether structured or unstructured, and transforming it into useful and meaningful information. An array is an example of data structure.\n\n3.  **Data Cleaning:** Data cleaning is a vital stage in the data science workflow, focusing on *detecting and rectifying errors, inconsistencies, and inaccuracies in the data to enhance its quality and usability*. This process is crucial because raw data often contains noise, gaps, and inconsistencies that can adversely affect the *accuracy and dependability* of the insights generated from it. Data cleaning involves preparing data for analysis by *correcting or eliminating data that is incorrect, incomplete, irrelevant, duplicated, or poorly formatted*. It involves steps such as *removing unwanted observations, managing structure errors, managing unwanted outliers and handling missing data*.\n\n4.  **Data Enriching:** After transforming your data into a more usable format, evaluate whether you have all the necessary information for your analysis. If not, you can enhance it by incorporating values from additional datasets. This is also a good time to consider adding metadata to your database.\n\n5.  **Data validation:** Once you’ve converted your data into a more usable format, assess if you have all the information required for your analysis. If anything is missing, you can augment it by integrating data from other sources. Additionally, this is an opportune moment to add metadata to your database. Validation *guarantees the quality and reliability of your processed data.* It involves checking for inconsistencies, verifying data integrity, and ensuring the data meets predefined standards. This process helps build confidence in the dataset's accuracy and ensures it is suitable for meaningful analysis.\n\n6.  **Data Publishing:** Data publishing refers to the process of making data available to users, often by sharing or disseminating it through various platforms or channels. This can involve publishing datasets on websites, data repositories, or databases, *ensuring that the data is accessible, usable, and properly documented for others to analyze or utilize.*\n\n    Also, there are three main aspect of data wrangling. These includes:\n\n    1.  Tibbles\n    2.  Data import\n    3.  Tidy data\n\n## [Tibbles]{style=\"color: #002D62;\"}\n\nTibbles are a key feature of the tidyverse, distinguishing it from most other R packages, which typically use standard data frames. You can convert a dataset to tibbles with `as_tibble()`\n\n**Example**\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse) #load tidyverse package \n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.5.1     ✔ tibble    3.2.1\n✔ lubridate 1.9.3     ✔ tidyr     1.3.1\n✔ purrr     1.0.2     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors\n```\n\n\n:::\n\n```{.r .cell-code}\nlibrary(agridat)  #load agridat package \ndat <- (australia.soybean) \ndat <-  as_tibble(dat)  #convert dataframe to tibble dat \n```\n:::\n\n\n<br><br>\n\nYou can create tibbles from raw data using `tibble()` as shown below\n\n**Example**\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntibble (   x = 1:10,   y = rep(1:5,2),   z = x + y )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 10 × 3\n       x     y     z\n   <int> <int> <int>\n 1     1     1     2\n 2     2     2     4\n 3     3     3     6\n 4     4     4     8\n 5     5     5    10\n 6     6     1     7\n 7     7     2     9\n 8     8     3    11\n 9     9     4    13\n10    10     5    15\n```\n\n\n:::\n:::\n\n\n<br><br>\n\n**What are the common differences between a tibble and a dataframe**\n\nA tibble is considered a neater format of a data frame and its often used in tidyverse and ggplot2 packages. Tibble has an advanced print function and only shows the first ten rows with all the columns fitted on the screen. The data type is written just below the heading of each column. This does not apply to data frame. Tibble can be used for indexing such as \\$, \\[\\[ \\]\\]. \\$ extracts using name while \\[\\[ \\]\\] extract by name and position.\n\n**Example**\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(234) \ndf <- tibble(   x = runif(5),   y = rnorm(5) )  # Extract by name df$x  \ndf[[\"x\"]]  # Extract by position df[[1]] \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.74562000 0.78171242 0.02003711 0.77608539 0.06691009\n```\n\n\n:::\n:::\n\n\n<br><br>\n\n## [Data Import]{style=\"color: #002D62;\"}\n\n**Importing a Comma Seperated Version (CSV)**\n\nData import can be done with the `readr` package which is a core `tidyverse` package. This is used for reading data stored in text file spreadsheets into R. Some readr's function are used in turning flat files into dataframe. You can load readr using the code `library(readr)`, this gives you access to functions such as: `read_csv()` for reading comma delimited files, `read_csv2()` for semicolon separated files, `read_table` for white space separated values etc.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#install readr package \ninstall.packages(\"readr\")  \n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: package 'readr' is in use and will not be installed\n```\n\n\n:::\n\n```{.r .cell-code}\n# load the package \nlibrary(readr)  \n#read the csv file into a tibble  \ndata <- read_csv(\"steptoe.morex.pheno.csv\")\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nRows: 2432 Columns: 10\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (2): gen, env\ndbl (8): amylase, diapow, hddate, lodging, malt, height, protein, yield\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n```\n\n\n:::\n\n```{.r .cell-code}\ndata\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2,432 × 10\n   gen     env   amylase diapow hddate lodging  malt height protein yield\n   <chr>   <chr>   <dbl>  <dbl>  <dbl>   <dbl> <dbl>  <dbl>   <dbl> <dbl>\n 1 Steptoe MN92     22.7     46   150.      NA  73.6   84.5    10.5  5.53\n 2 Steptoe MTi92    30.1     72   178       10  76.5   NA      11.2  8.64\n 3 Steptoe MTd92    26.7     78   165       15  74.5   75.5    13.4  5.90\n 4 Steptoe ID91     26.2     74   179       NA  74.1  111      12.1  8.63\n 5 Steptoe OR91     19.6     62   191       NA  71.5   90      11.7  5.34\n 6 Steptoe WA91     23.6     54   181       NA  73.8  112      10    6.27\n 7 Steptoe MTi91    21       62   181       NA  70.8   98      12    4.10\n 8 Steptoe MTd91    NA       NA   181       NA  NA     82      NA    7.07\n 9 Steptoe NY92     NA       NA   176        0  NA     77.5    NA    6.05\n10 Steptoe ON92     NA       NA   198       50  NA     95      NA    3.70\n# ℹ 2,422 more rows\n```\n\n\n:::\n:::\n\n\n<br><br>\n\n**Importing an Excel Version (XLSL)**\n\nThe readxl library can also be assessed from the readr package and it is used to import excel files. The functions to import excel files are `read_excel()` or `read_xlsx()`. The `read_excel()` auto detect the format while `read_xlsl()`permits more than two sheets in a file.\n\n**Example**\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#install the readxl package \ninstall.packages(\"readxl\")   \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\npackage 'readxl' successfully unpacked and MD5 sums checked\n\nThe downloaded binary packages are in\n\tC:\\Users\\DOjekere\\AppData\\Local\\Temp\\Rtmpiy0Xpa\\downloaded_packages\n```\n\n\n:::\n\n```{.r .cell-code}\n#load the readxl package \nlibrary(readxl) \n#Read the Excel file into a tibble \ndat <-  read_excel(\"Sugar cane.xlsx\", sheet = \"Sugar cane\") \ndat \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 30 × 6\n   Choice Stalks Height Diameter  Cane Variety\n    <dbl>  <dbl>  <dbl>    <dbl> <dbl>   <dbl>\n 1      1     23   2.37     1.7  12.4        2\n 2      0     11   2.25     1.68  5.49       3\n 3      0      9   2.5      1.93  6.59       2\n 4      1     25   2.4      2.12 21.2        2\n 5      1     20   2.5      1.7  11.4        1\n 6      0     12   1.9      1.51  4.08       1\n 7      0     12   1.7      1.34  2.88       3\n 8      1     16   2.4      1.84 10.2        1\n 9      0      4   2.4      2.11  3.36       3\n10      1     11   2.35     2     8.12       1\n# ℹ 20 more rows\n```\n\n\n:::\n:::\n\n\n<br><br>\n\n## [Tidy Data]{style=\"color: #002D62;\"}\n\nTidy data considers ways to convert your messy dataset into format that are clean and can be easily analysed. The aim of tidyr is to assist in creating tidy data, where:\n\n-   Each variable is represented as a column, and each column corresponds to a variable.\n-   Each observation is represented as a row, and each row corresponds to an observation.\n-   Each value is contained within a cell, with each cell holding a single value.\n\nThe principles of tidy data offer a standardized method for organizing data values within a dataset. The tidy data standard is designed to ease the initial exploration and analysis of data and to streamline the creation of data analysis tools that integrate seamlessly.\n\nVarious functions can be used in the tidyr package, functions such as *pivoting (longer and wider), rectangling, nesting, splitting, replace and drop na* etc.\n\n# [**Examples**]{style=\"color: #2C6D26;\"}\n\n## [Data Frame]{style=\"color: #002D62;\"}\n\n**Let's create a data frame**\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntrial01 <- data.frame(   variety = c(\"G01-US234\", \"G05-BT456\", \"Ind01\",\"G11-DR234\", \"Check\"),    yield = c(6323.3, 2515.2, 5611, 7729, 7843.25),   height = c(123.30, 95.2, 113, 89.45, 145.67)   )\n```\n:::\n\n\n**Let's display the data frame**\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntrial01  \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n    variety   yield height\n1 G01-US234 6323.30 123.30\n2 G05-BT456 2515.20  95.20\n3     Ind01 5611.00 113.00\n4 G11-DR234 7729.00  89.45\n5     Check 7843.25 145.67\n```\n\n\n:::\n\n```{.r .cell-code}\n## display the object in Q2 \nView(trial01) ## display the object in Q1  \n#trial01[R,C] \ntrial01[1:5,]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n    variety   yield height\n1 G01-US234 6323.30 123.30\n2 G05-BT456 2515.20  95.20\n3     Ind01 5611.00 113.00\n4 G11-DR234 7729.00  89.45\n5     Check 7843.25 145.67\n```\n\n\n:::\n:::\n\n\n<br><br>\n\n**We can extract the first three rows:**\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# object[1:nrows, 1:ncolumns] \ntrial01[1:5, 1:3] \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n    variety   yield height\n1 G01-US234 6323.30 123.30\n2 G05-BT456 2515.20  95.20\n3     Ind01 5611.00 113.00\n4 G11-DR234 7729.00  89.45\n5     Check 7843.25 145.67\n```\n\n\n:::\n\n```{.r .cell-code}\ntrial01[1:3, ] # the three first rows and all columns\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n    variety  yield height\n1 G01-US234 6323.3  123.3\n2 G05-BT456 2515.2   95.2\n3     Ind01 5611.0  113.0\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# We can extract the first two columns \ntrial01[, 1:2] \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n    variety   yield\n1 G01-US234 6323.30\n2 G05-BT456 2515.20\n3     Ind01 5611.00\n4 G11-DR234 7729.00\n5     Check 7843.25\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# We can extract \"from 3rd to 5th row\" with \"2nd and 3rd column\" \ntrial01[3:5, 2:3]  \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n    yield height\n3 5611.00 113.00\n4 7729.00  89.45\n5 7843.25 145.67\n```\n\n\n:::\n\n```{.r .cell-code}\ntrial01[,c(1,3)]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n    variety height\n1 G01-US234 123.30\n2 G05-BT456  95.20\n3     Ind01 113.00\n4 G11-DR234  89.45\n5     Check 145.67\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# We can list the column names using any of this methods \nnames(trial01)  \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"variety\" \"yield\"   \"height\" \n```\n\n\n:::\n\n```{.r .cell-code}\ncolnames(trial01)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"variety\" \"yield\"   \"height\" \n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# We can extract specific column from a data frame using column name \ntrial01$yield1 <- trial01$yield  \ntrial01$yield  \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 6323.30 2515.20 5611.00 7729.00 7843.25\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# trial01$Yield. R is case sensitive, yield is different from Yield  \n# We can find the mean of the extracted column using any of the codes below  \nmean(trial01$yield) \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 6004.35\n```\n\n\n:::\n\n```{.r .cell-code}\nmean(trial01$yield) \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 6004.35\n```\n\n\n:::\n:::\n\n\n```{r} # We can add a column vector using a new column name}\ntrial01$flowering <- c(87, 101, 88, 120, 90) \ntrial01$flowering <- c(87,101,88,120,90) \ntrial01  \nflowering2 <- c(87,101,88,120,90)  \ntrial01$flowerin2 <- flowering2  \ntrial01\n```\n\n<br><br>\n\n## [The tidyverse package]{style=\"color: #002D62;\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse) \ntrial01  # Let's look at the structure of trial01  \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n    variety   yield height  yield1\n1 G01-US234 6323.30 123.30 6323.30\n2 G05-BT456 2515.20  95.20 2515.20\n3     Ind01 5611.00 113.00 5611.00\n4 G11-DR234 7729.00  89.45 7729.00\n5     Check 7843.25 145.67 7843.25\n```\n\n\n:::\n\n```{.r .cell-code}\nstr(trial01) ## structure of trial01: what's trial01?\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n'data.frame':\t5 obs. of  4 variables:\n $ variety: chr  \"G01-US234\" \"G05-BT456\" \"Ind01\" \"G11-DR234\" ...\n $ yield  : num  6323 2515 5611 7729 7843\n $ height : num  123.3 95.2 113 89.5 145.7\n $ yield1 : num  6323 2515 5611 7729 7843\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# we can convert trial01 to a tibble and save the new created object into trial01.tibble \ntrial01.new <- as_tibble(trial01)  \ntrial01.new # dbl(double) and int(integer) are numeric\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 × 4\n  variety   yield height yield1\n  <chr>     <dbl>  <dbl>  <dbl>\n1 G01-US234 6323.  123.   6323.\n2 G05-BT456 2515.   95.2  2515.\n3 Ind01     5611   113    5611 \n4 G11-DR234 7729    89.4  7729 \n5 Check     7843.  146.   7843.\n```\n\n\n:::\n:::\n\n\n## [**Data Import**]{style=\"color: #002D62;\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Read csv file: supply the path to a file and you get the data into R  \nlibrary(readr) \nmydata <- read_csv(\"C:/Users/DOjekere/CGIAR/Fowobaje, Kayode Rapheal (IITA) - Training Materials/2024/R/RMD Training/Example-02.csv\") \n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nRows: 464 Columns: 10\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (3): env, loc, gen\ndbl (7): year, yield, height, lodging, size, protein, oil\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n```\n\n\n:::\n\n```{.r .cell-code}\nmydata   \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 464 × 10\n   env   loc    year gen   yield height lodging  size protein   oil\n   <chr> <chr> <dbl> <chr> <dbl>  <dbl>   <dbl> <dbl>   <dbl> <dbl>\n 1 L70   Lawes  1970 G01    2.39  1.44     4.25  8.45    36.7  20.9\n 2 L70   Lawes  1970 G02    2.28  1.45     4.25  9.95    37.6  20.7\n 3 L70   Lawes  1970 G03    2.57  1.46     3.75 10.8     37.8  21.3\n 4 L70   Lawes  1970 G04    2.88  1.26     3.5  10.0     38.4  22.0\n 5 L70   Lawes  1970 G05    2.39  1.34     3.5  11       37.5  22.1\n 6 L70   Lawes  1970 G06    2.41  1.36     4    11.8     38.2  21.2\n 7 L70   Lawes  1970 G07    2.70  1.3      3    11.8     37.4  21.7\n 8 L70   Lawes  1970 G08    2.46  0.955    3.25 10       35.2  21.1\n 9 L70   Lawes  1970 G09    2.57  1.03     3    11.2     35.9  21.5\n10 L70   Lawes  1970 G10    2.98  1.16     3.75 10.8     39.7  20.4\n# ℹ 454 more rows\n```\n\n\n:::\n\n```{.r .cell-code}\n# If a project/working directory is created and we are working within the project,  \nmydata1 <- read_csv(\"Example-02.csv\") # Tab keyboard\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nRows: 464 Columns: 10\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (3): env, loc, gen\ndbl (7): year, yield, height, lodging, size, protein, oil\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n## Read xlsx file library(readxl) \niwu <- read_excel(\"C:/Users/DOjekere/CGIAR/Fowobaje, Kayode Rapheal (IITA) - Training Materials/2024/R/RMD Training/Example-03.xlsx\", sheet = \"whitecorn\")  \n## Read Excel file: \nmydata2 <- read_excel(\"Example-03.xlsx\", sheet = \"whitecorn\") \nView(mydata2) \nmydata2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 540 × 9\n   loc          gen       yield stand rootlodge stalklodge earht flower moisture\n   <chr>        <chr>     <dbl> <dbl>     <dbl>      <dbl> <dbl>  <dbl>    <dbl>\n 1 Knoxville,TN AgriGold…  138.  91.1         0        0    47.3   67.3     21.7\n 2 Knoxville,TN AgriGold…  151   86.1         0        0.6  45     67.7     21.5\n 3 Knoxville,TN Asgrow_X…  140.  94.4         0        0.6  46.3   67       19.8\n 4 Knoxville,TN Beck_Ex2…  190.  90           0        0    57     67.3     19.4\n 5 Knoxville,TN Crows_W54  141.  88.9         0        0.6  47     68.7     21.1\n 6 Knoxville,TN Crows_W55  139.  88.9         0        1.2  52     66.7     20  \n 7 Knoxville,TN Crows_EX…  179.  88.9         0        0.7  47     67.3     20.2\n 8 Knoxville,TN Crows_EX…  180   94.4         0        1.8  49     67.7     19.9\n 9 Knoxville,TN Dekalb_D…  166.  98.9         0        0.6  47     67       21.3\n10 Knoxville,TN Dekalb_D…  169.  99.4         0        1.1  37     65.3     19.1\n# ℹ 530 more rows\n```\n\n\n:::\n:::\n\n\n## [Data Transformation]{style=\"color: #002D62;\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)  \nexample02 <- read_csv(\"Example-02.csv\")\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nRows: 464 Columns: 10\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (3): env, loc, gen\ndbl (7): year, yield, height, lodging, size, protein, oil\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n```\n\n\n:::\n\n```{.r .cell-code}\nexample02 \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 464 × 10\n   env   loc    year gen   yield height lodging  size protein   oil\n   <chr> <chr> <dbl> <chr> <dbl>  <dbl>   <dbl> <dbl>   <dbl> <dbl>\n 1 L70   Lawes  1970 G01    2.39  1.44     4.25  8.45    36.7  20.9\n 2 L70   Lawes  1970 G02    2.28  1.45     4.25  9.95    37.6  20.7\n 3 L70   Lawes  1970 G03    2.57  1.46     3.75 10.8     37.8  21.3\n 4 L70   Lawes  1970 G04    2.88  1.26     3.5  10.0     38.4  22.0\n 5 L70   Lawes  1970 G05    2.39  1.34     3.5  11       37.5  22.1\n 6 L70   Lawes  1970 G06    2.41  1.36     4    11.8     38.2  21.2\n 7 L70   Lawes  1970 G07    2.70  1.3      3    11.8     37.4  21.7\n 8 L70   Lawes  1970 G08    2.46  0.955    3.25 10       35.2  21.1\n 9 L70   Lawes  1970 G09    2.57  1.03     3    11.2     35.9  21.5\n10 L70   Lawes  1970 G10    2.98  1.16     3.75 10.8     39.7  20.4\n# ℹ 454 more rows\n```\n\n\n:::\n\n```{.r .cell-code}\nnames(example02) \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] \"env\"     \"loc\"     \"year\"    \"gen\"     \"yield\"   \"height\"  \"lodging\"\n [8] \"size\"    \"protein\" \"oil\"    \n```\n\n\n:::\n\n```{.r .cell-code}\nstr(example02)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nspc_tbl_ [464 × 10] (S3: spec_tbl_df/tbl_df/tbl/data.frame)\n $ env    : chr [1:464] \"L70\" \"L70\" \"L70\" \"L70\" ...\n $ loc    : chr [1:464] \"Lawes\" \"Lawes\" \"Lawes\" \"Lawes\" ...\n $ year   : num [1:464] 1970 1970 1970 1970 1970 1970 1970 1970 1970 1970 ...\n $ gen    : chr [1:464] \"G01\" \"G02\" \"G03\" \"G04\" ...\n $ yield  : num [1:464] 2.39 2.28 2.57 2.88 2.39 ...\n $ height : num [1:464] 1.45 1.45 1.46 1.26 1.33 ...\n $ lodging: num [1:464] 4.25 4.25 3.75 3.5 3.5 4 3 3.25 3 3.75 ...\n $ size   : num [1:464] 8.45 9.95 10.85 10.05 11 ...\n $ protein: num [1:464] 36.7 37.5 37.8 38.5 37.5 ...\n $ oil    : num [1:464] 20.9 20.7 21.3 22 22.1 ...\n - attr(*, \"spec\")=\n  .. cols(\n  ..   env = col_character(),\n  ..   loc = col_character(),\n  ..   year = col_double(),\n  ..   gen = col_character(),\n  ..   yield = col_double(),\n  ..   height = col_double(),\n  ..   lodging = col_double(),\n  ..   size = col_double(),\n  ..   protein = col_double(),\n  ..   oil = col_double()\n  .. )\n - attr(*, \"problems\")=<externalptr> \n```\n\n\n:::\n\n```{.r .cell-code}\n## really don't need when you have tibble  # I want to display the number of years \n\nhead(example02$year) \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1970 1970 1970 1970 1970 1970\n```\n\n\n:::\n\n```{.r .cell-code}\nunique(example02$year) \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1970 1971\n```\n\n\n:::\n\n```{.r .cell-code}\nunique(example02$loc) # having the number of locations \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Lawes\"      \"Brookstead\" \"Nambour\"    \"RedlandBay\"\n```\n\n\n:::\n:::\n\n\n<br><br>\n\n**The pipe \\|\\>**\n\nPipes are a powerful tool for clearly expressing a sequence of multiple operations. Object \\|\\> (object is usually a tibble, a data) Function(argument1, argument2, ...)\n\n### **Filter**\n\nWe can filter the data for 1970\n\n\n::: {.cell}\n\n```{.r .cell-code}\nexample02.70 <- example02 |>    \n  filter(year == 1970)\n\nexample02.70\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 232 × 10\n   env   loc    year gen   yield height lodging  size protein   oil\n   <chr> <chr> <dbl> <chr> <dbl>  <dbl>   <dbl> <dbl>   <dbl> <dbl>\n 1 L70   Lawes  1970 G01    2.39  1.44     4.25  8.45    36.7  20.9\n 2 L70   Lawes  1970 G02    2.28  1.45     4.25  9.95    37.6  20.7\n 3 L70   Lawes  1970 G03    2.57  1.46     3.75 10.8     37.8  21.3\n 4 L70   Lawes  1970 G04    2.88  1.26     3.5  10.0     38.4  22.0\n 5 L70   Lawes  1970 G05    2.39  1.34     3.5  11       37.5  22.1\n 6 L70   Lawes  1970 G06    2.41  1.36     4    11.8     38.2  21.2\n 7 L70   Lawes  1970 G07    2.70  1.3      3    11.8     37.4  21.7\n 8 L70   Lawes  1970 G08    2.46  0.955    3.25 10       35.2  21.1\n 9 L70   Lawes  1970 G09    2.57  1.03     3    11.2     35.9  21.5\n10 L70   Lawes  1970 G10    2.98  1.16     3.75 10.8     39.7  20.4\n# ℹ 222 more rows\n```\n\n\n:::\n:::\n\n\nFiltering using the pipe is equivalent to below but not nice\n\n\n::: {.cell}\n\n```{.r .cell-code}\nexample02.70.not.nice <- example02[example02$year==1970,]  \nexample02.70.not.nice \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 232 × 10\n   env   loc    year gen   yield height lodging  size protein   oil\n   <chr> <chr> <dbl> <chr> <dbl>  <dbl>   <dbl> <dbl>   <dbl> <dbl>\n 1 L70   Lawes  1970 G01    2.39  1.44     4.25  8.45    36.7  20.9\n 2 L70   Lawes  1970 G02    2.28  1.45     4.25  9.95    37.6  20.7\n 3 L70   Lawes  1970 G03    2.57  1.46     3.75 10.8     37.8  21.3\n 4 L70   Lawes  1970 G04    2.88  1.26     3.5  10.0     38.4  22.0\n 5 L70   Lawes  1970 G05    2.39  1.34     3.5  11       37.5  22.1\n 6 L70   Lawes  1970 G06    2.41  1.36     4    11.8     38.2  21.2\n 7 L70   Lawes  1970 G07    2.70  1.3      3    11.8     37.4  21.7\n 8 L70   Lawes  1970 G08    2.46  0.955    3.25 10       35.2  21.1\n 9 L70   Lawes  1970 G09    2.57  1.03     3    11.2     35.9  21.5\n10 L70   Lawes  1970 G10    2.98  1.16     3.75 10.8     39.7  20.4\n# ℹ 222 more rows\n```\n\n\n:::\n:::\n\n\nWe can filter the data for one location :\n\n\n::: {.cell}\n\n```{.r .cell-code}\nexample02.Lawes <- example02 |>    \n  filter(loc == \"Lawes\")  \n\nexample02.Lawes \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 116 × 10\n   env   loc    year gen   yield height lodging  size protein   oil\n   <chr> <chr> <dbl> <chr> <dbl>  <dbl>   <dbl> <dbl>   <dbl> <dbl>\n 1 L70   Lawes  1970 G01    2.39  1.44     4.25  8.45    36.7  20.9\n 2 L70   Lawes  1970 G02    2.28  1.45     4.25  9.95    37.6  20.7\n 3 L70   Lawes  1970 G03    2.57  1.46     3.75 10.8     37.8  21.3\n 4 L70   Lawes  1970 G04    2.88  1.26     3.5  10.0     38.4  22.0\n 5 L70   Lawes  1970 G05    2.39  1.34     3.5  11       37.5  22.1\n 6 L70   Lawes  1970 G06    2.41  1.36     4    11.8     38.2  21.2\n 7 L70   Lawes  1970 G07    2.70  1.3      3    11.8     37.4  21.7\n 8 L70   Lawes  1970 G08    2.46  0.955    3.25 10       35.2  21.1\n 9 L70   Lawes  1970 G09    2.57  1.03     3    11.2     35.9  21.5\n10 L70   Lawes  1970 G10    2.98  1.16     3.75 10.8     39.7  20.4\n# ℹ 106 more rows\n```\n\n\n:::\n:::\n\n\nWe can filter the data with multiple criteria (several arguments)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nexample02.Lawes3.2 <- example02 |>    \n  filter(yield > 3.2, loc == \"Lawes\") \n\nexample02.Lawes3.2 <- example02 |>  \n  filter(yield >3.2, loc == \"Brookstead\" | loc == \"Lawes\")  \nexample02.Lawes3.2 \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 17 × 10\n   env   loc         year gen   yield height lodging  size protein   oil\n   <chr> <chr>      <dbl> <chr> <dbl>  <dbl>   <dbl> <dbl>   <dbl> <dbl>\n 1 L70   Lawes       1970 G26    3.21  1.18     4     9.55    39.8  20.1\n 2 L70   Lawes       1970 G45    3.26  0.785    2.75 23.2     37    23.7\n 3 L70   Lawes       1970 G48    4.38  0.76     3.75 18.8     38.2  24.4\n 4 L70   Lawes       1970 G50    3.38  0.835    2.75 17.9     39.9  24.6\n 5 L71   Lawes       1971 G45    3.82  0.56     1.25 19.6     36.3  23.7\n 6 L71   Lawes       1971 G48    3.57  0.545    1.25 17.0     39.1  24.1\n 7 L71   Lawes       1971 G49    3.44  0.66     1.25 18.6     37.5  23.1\n 8 L71   Lawes       1971 G57    3.39  0.685    1.5  19.4     38.6  22.8\n 9 B71   Brookstead  1971 G45    3.75  0.735    2.5  23.6     37.9  22.1\n10 B71   Brookstead  1971 G46    3.37  0.735    2.75 18.1     38.3  20.5\n11 B71   Brookstead  1971 G47    3.45  0.725    1.75 20.7     39.6  23.2\n12 B71   Brookstead  1971 G49    3.90  1.00     2.25 21.6     37.5  22.2\n13 B71   Brookstead  1971 G50    3.61  0.75     3    19.3     40.2  23.3\n14 B71   Brookstead  1971 G53    3.82  0.675    1.75 21.9     39.0  22.1\n15 B71   Brookstead  1971 G55    3.48  0.57     1.25 20.0     41.6  21.9\n16 B71   Brookstead  1971 G56    3.54  0.69     1.25 21.4     41.0  22.1\n17 B71   Brookstead  1971 G57    3.58  0.635    1.25 22.9     41.4  21.7\n```\n\n\n:::\n:::\n\n\nWhat does the following command do?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nexample02 |>    filter(gen == \"G01\" | gen == \"G02\") \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 16 × 10\n   env   loc         year gen   yield height lodging  size protein   oil\n   <chr> <chr>      <dbl> <chr> <dbl>  <dbl>   <dbl> <dbl>   <dbl> <dbl>\n 1 L70   Lawes       1970 G01   2.39   1.44     4.25  8.45    36.7  20.9\n 2 L70   Lawes       1970 G02   2.28   1.45     4.25  9.95    37.6  20.7\n 3 B70   Brookstead  1970 G01   1.25   1.01     3.25  8.85    39.5  18.8\n 4 B70   Brookstead  1970 G02   1.17   1.13     2.75  8.9     38.6  19.8\n 5 N70   Nambour     1970 G01   2.26   0.75     2.25  9.25    34.2  22.3\n 6 N70   Nambour     1970 G02   2.16   0.71     2     9.35    37.6  22.4\n 7 R70   RedlandBay  1970 G01   0.778  0.9      3.25  6.25    40.8  15.9\n 8 R70   RedlandBay  1970 G02   1.09   0.9      3.75  7.35    41.0  17.6\n 9 L71   Lawes       1971 G01   2.79   0.97     2.5   8.35    39.4  18.7\n10 L71   Lawes       1971 G02   2.62   0.785    2.25  9.75    40.6  19.8\n11 B71   Brookstead  1971 G01   2.56   0.965    3.25  8.9     40.3  18.2\n12 B71   Brookstead  1971 G02   2.34   0.835    2.75 10.9     41.8  18.8\n13 N71   Nambour     1971 G01   2.10   0.725    1.25  7.3     38.5  19.3\n14 N71   Nambour     1971 G02   2.6    0.595    1     9.45    41.0  20.7\n15 R71   RedlandBay  1971 G01   1.18   0.97     2.25  6.75    42.1  16.9\n16 R71   RedlandBay  1971 G02   1.90   0.74     1.75  7.95    42.7  18.9\n```\n\n\n:::\n:::\n\n\n### **Arrange**\n\nWe can arrange example02 by yield in ascending order\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse) \nlibrary(readxl)\nexample02 <- read_csv(\"Example-02.csv\")  \n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nRows: 464 Columns: 10\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (3): env, loc, gen\ndbl (7): year, yield, height, lodging, size, protein, oil\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n```\n\n\n:::\n\n```{.r .cell-code}\nexample02 |>    arrange(yield)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 464 × 10\n   env   loc         year gen   yield height lodging  size protein   oil\n   <chr> <chr>      <dbl> <chr> <dbl>  <dbl>   <dbl> <dbl>   <dbl> <dbl>\n 1 N70   Nambour     1970 G58   0.282  0.395    1    17.4     39.2  20.8\n 2 R70   RedlandBay  1970 G36   0.365  0.915    3.75  6.15    42.9  14.3\n 3 B70   Brookstead  1970 G08   0.385  1.12     2.25  6.15    38.5  17.9\n 4 B70   Brookstead  1970 G30   0.424  1.07     2.5   5.75    40.2  16.5\n 5 R70   RedlandBay  1970 G11   0.455  1.00     3.5   4       42.9  14.2\n 6 B70   Brookstead  1970 G52   0.466  0.56     1.25 10.2     40.4  17.4\n 7 B70   Brookstead  1970 G03   0.468  1.16     2.25 10.8     37.8  20.4\n 8 R70   RedlandBay  1970 G17   0.487  0.89     3.25  5.65    44.8  13.1\n 9 R70   RedlandBay  1970 G12   0.492  1.05     3.25  4.1     41.8  13.9\n10 R70   RedlandBay  1970 G31   0.517  0.93     3.5   6.7     42.6  15.6\n# ℹ 454 more rows\n```\n\n\n:::\n:::\n\n\nWe can arrange example02 by yield in descending order\n\n\n::: {.cell}\n\n```{.r .cell-code}\nexample02 |>    arrange(desc(yield))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 464 × 10\n   env   loc         year gen   yield height lodging  size protein   oil\n   <chr> <chr>      <dbl> <chr> <dbl>  <dbl>   <dbl> <dbl>   <dbl> <dbl>\n 1 L70   Lawes       1970 G48    4.38  0.76     3.75  18.8    38.2  24.4\n 2 R70   RedlandBay  1970 G56    4.13  0.56     2.25  19.0    38    24.0\n 3 R71   RedlandBay  1971 G49    4.00  0.905    1.75  17.2    36.6  22.6\n 4 B71   Brookstead  1971 G49    3.90  1.00     2.25  21.6    37.5  22.2\n 5 L71   Lawes       1971 G45    3.82  0.56     1.25  19.6    36.3  23.7\n 6 B71   Brookstead  1971 G53    3.82  0.675    1.75  21.9    39.0  22.1\n 7 B71   Brookstead  1971 G45    3.75  0.735    2.5   23.6    37.9  22.1\n 8 R70   RedlandBay  1970 G57    3.67  0.545    1.75  16.6    38.2  23.7\n 9 R70   RedlandBay  1970 G49    3.62  1.02     3.5   14.2    36.3  23.4\n10 B71   Brookstead  1971 G50    3.61  0.75     3     19.3    40.2  23.3\n# ℹ 454 more rows\n```\n\n\n:::\n:::\n\n\nWe can arrange example02 by year, loc, gen\n\n\n::: {.cell}\n\n```{.r .cell-code}\nexample02 |>    arrange(year, loc, gen) \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 464 × 10\n   env   loc         year gen   yield height lodging  size protein   oil\n   <chr> <chr>      <dbl> <chr> <dbl>  <dbl>   <dbl> <dbl>   <dbl> <dbl>\n 1 B70   Brookstead  1970 G01   1.25    1.01    3.25  8.85    39.5  18.8\n 2 B70   Brookstead  1970 G02   1.17    1.13    2.75  8.9     38.6  19.8\n 3 B70   Brookstead  1970 G03   0.468   1.16    2.25 10.8     37.8  20.4\n 4 B70   Brookstead  1970 G04   1.44    1.24    1.5  10.6     38.7  20.4\n 5 B70   Brookstead  1970 G05   1.34    1.12    2    12.0     37.8  20.8\n 6 B70   Brookstead  1970 G06   0.913   1.10    2.25 11       37.4  19.9\n 7 B70   Brookstead  1970 G07   1.24    1.13    2    10.2     37.8  20.3\n 8 B70   Brookstead  1970 G08   0.385   1.12    2.25  6.15    38.5  17.9\n 9 B70   Brookstead  1970 G09   1.11    1.04    1.75  8.3     37.9  20.0\n10 B70   Brookstead  1970 G10   1.80    1.04    2    11.8     38.4  19.7\n# ℹ 454 more rows\n```\n\n\n:::\n\n```{.r .cell-code}\nexample02 |>    arrange(desc(year), loc, gen) \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 464 × 10\n   env   loc         year gen   yield height lodging  size protein   oil\n   <chr> <chr>      <dbl> <chr> <dbl>  <dbl>   <dbl> <dbl>   <dbl> <dbl>\n 1 B71   Brookstead  1971 G01    2.56  0.965    3.25   8.9    40.3  18.2\n 2 B71   Brookstead  1971 G02    2.34  0.835    2.75  10.9    41.8  18.8\n 3 B71   Brookstead  1971 G03    2.87  0.98     3.25  12.4    39.8  19.6\n 4 B71   Brookstead  1971 G04    3.01  0.9      2.25  12.8    38.5  19.5\n 5 B71   Brookstead  1971 G05    2.54  0.975    3.25  13.3    39.4  19.9\n 6 B71   Brookstead  1971 G06    1.88  0.94     3.25  12.8    37.6  19.6\n 7 B71   Brookstead  1971 G07    2.56  0.95     2.75  14      37.4  19.5\n 8 B71   Brookstead  1971 G08    1.61  0.915    3     12.3    37.7  19.0\n 9 B71   Brookstead  1971 G09    2.24  0.85     2.75  12.0    39.6  18.2\n10 B71   Brookstead  1971 G10    2.60  0.81     2.5   13.4    40.0  18.6\n# ℹ 454 more rows\n```\n\n\n:::\n:::\n\n\n### **Select**\n\nWhen working with many variables, it can be a good practice to narrow the dataset and consider only few variables for analysis. Let's only consider the location, year, genotype, yield, and height\n\n\n::: {.cell}\n\n```{.r .cell-code}\nexample02.short <- example02 |>   \n  select(loc, year, gen, yield, height)  \n\nexample02.short\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 464 × 5\n   loc    year gen   yield height\n   <chr> <dbl> <chr> <dbl>  <dbl>\n 1 Lawes  1970 G01    2.39  1.44 \n 2 Lawes  1970 G02    2.28  1.45 \n 3 Lawes  1970 G03    2.57  1.46 \n 4 Lawes  1970 G04    2.88  1.26 \n 5 Lawes  1970 G05    2.39  1.34 \n 6 Lawes  1970 G06    2.41  1.36 \n 7 Lawes  1970 G07    2.70  1.3  \n 8 Lawes  1970 G08    2.46  0.955\n 9 Lawes  1970 G09    2.57  1.03 \n10 Lawes  1970 G10    2.98  1.16 \n# ℹ 454 more rows\n```\n\n\n:::\n:::\n\n\nIf we are interested in moving a particular variable to the first column in the dataframe, select() and everything() can do that. We can also move more than one variable\n\n\n::: {.cell}\n\n```{.r .cell-code}\nexample02 |>    select(year, everything())  \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 464 × 10\n    year env   loc   gen   yield height lodging  size protein   oil\n   <dbl> <chr> <chr> <chr> <dbl>  <dbl>   <dbl> <dbl>   <dbl> <dbl>\n 1  1970 L70   Lawes G01    2.39  1.44     4.25  8.45    36.7  20.9\n 2  1970 L70   Lawes G02    2.28  1.45     4.25  9.95    37.6  20.7\n 3  1970 L70   Lawes G03    2.57  1.46     3.75 10.8     37.8  21.3\n 4  1970 L70   Lawes G04    2.88  1.26     3.5  10.0     38.4  22.0\n 5  1970 L70   Lawes G05    2.39  1.34     3.5  11       37.5  22.1\n 6  1970 L70   Lawes G06    2.41  1.36     4    11.8     38.2  21.2\n 7  1970 L70   Lawes G07    2.70  1.3      3    11.8     37.4  21.7\n 8  1970 L70   Lawes G08    2.46  0.955    3.25 10       35.2  21.1\n 9  1970 L70   Lawes G09    2.57  1.03     3    11.2     35.9  21.5\n10  1970 L70   Lawes G10    2.98  1.16     3.75 10.8     39.7  20.4\n# ℹ 454 more rows\n```\n\n\n:::\n\n```{.r .cell-code}\nexample02 |>    select(year, loc, gen, everything())\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 464 × 10\n    year loc   gen   env   yield height lodging  size protein   oil\n   <dbl> <chr> <chr> <chr> <dbl>  <dbl>   <dbl> <dbl>   <dbl> <dbl>\n 1  1970 Lawes G01   L70    2.39  1.44     4.25  8.45    36.7  20.9\n 2  1970 Lawes G02   L70    2.28  1.45     4.25  9.95    37.6  20.7\n 3  1970 Lawes G03   L70    2.57  1.46     3.75 10.8     37.8  21.3\n 4  1970 Lawes G04   L70    2.88  1.26     3.5  10.0     38.4  22.0\n 5  1970 Lawes G05   L70    2.39  1.34     3.5  11       37.5  22.1\n 6  1970 Lawes G06   L70    2.41  1.36     4    11.8     38.2  21.2\n 7  1970 Lawes G07   L70    2.70  1.3      3    11.8     37.4  21.7\n 8  1970 Lawes G08   L70    2.46  0.955    3.25 10       35.2  21.1\n 9  1970 Lawes G09   L70    2.57  1.03     3    11.2     35.9  21.5\n10  1970 Lawes G10   L70    2.98  1.16     3.75 10.8     39.7  20.4\n# ℹ 454 more rows\n```\n\n\n:::\n:::\n\n\n**NOTE:** Select refers to columns: select (yield, loc, gen) -- choose the columns arrange refers to rows: arrange(loc, desc(yield)) -- sort\n\n\n::: {.cell}\n\n```{.r .cell-code}\nexample02 |>    select (yield, loc, gen) \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 464 × 3\n   yield loc   gen  \n   <dbl> <chr> <chr>\n 1  2.39 Lawes G01  \n 2  2.28 Lawes G02  \n 3  2.57 Lawes G03  \n 4  2.88 Lawes G04  \n 5  2.39 Lawes G05  \n 6  2.41 Lawes G06  \n 7  2.70 Lawes G07  \n 8  2.46 Lawes G08  \n 9  2.57 Lawes G09  \n10  2.98 Lawes G10  \n# ℹ 454 more rows\n```\n\n\n:::\n:::\n\n\nThis code will not work because there is no variable named \"desc(yield)\"\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#example02 |>         #  select (loc, gen, desc(yield))\n```\n:::\n\n\nBut what we want is:\n\n```         \n1. select the three variables, AND 2. sort the yield in desc order\n```\n\nThis can be done with:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnew <- example02 |>    \n  select (loc, gen, yield) |>    \n  arrange(desc(yield))\n```\n:::\n\n\n<br><br>\n\n### **Add New Variable**\n\nWe can add new columns that are functions of existing columns with `mutate()` which always adds new columns at the end of the data new column\n\n```{r} new1 <- example02.short |>}\n  mutate(yield_kg_ha = yield * 1000)\n```\n\n**Replace an existing column**\n\n```{r} new2 <- example02.short |>}\n  mutate(yield = yield * 1000)\n```\n\n### **Summarize**\n\nWe can be interested having the mean of yield\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmean(example02$yield, na.rm = TRUE) \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2.047427\n```\n\n\n:::\n\n```{.r .cell-code}\na <- c(2,3,4)\na \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2 3 4\n```\n\n\n:::\n\n```{.r .cell-code}\nmean(a) \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3\n```\n\n\n:::\n\n```{.r .cell-code}\nmean(a, na.rm = TRUE)  \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3\n```\n\n\n:::\n\n```{.r .cell-code}\nb <- c(2,3,4,NA) \nb \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  2  3  4 NA\n```\n\n\n:::\n\n```{.r .cell-code}\nmean(b) \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] NA\n```\n\n\n:::\n\n```{.r .cell-code}\nmean(b, na.rm = TRUE)  \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3\n```\n\n\n:::\n\n```{.r .cell-code}\nsummary(example02) # summary of the dataframe \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     env                loc                 year          gen           \n Length:464         Length:464         Min.   :1970   Length:464        \n Class :character   Class :character   1st Qu.:1970   Class :character  \n Mode  :character   Mode  :character   Median :1970   Mode  :character  \n                                       Mean   :1970                     \n                                       3rd Qu.:1971                     \n                                       Max.   :1971                     \n     yield           height          lodging          size       \n Min.   :0.282   Min.   :0.2500   Min.   :1.00   Min.   : 4.000  \n 1st Qu.:1.515   1st Qu.:0.7075   1st Qu.:1.50   1st Qu.: 7.838  \n Median :2.075   Median :0.8875   Median :2.25   Median : 9.500  \n Mean   :2.047   Mean   :0.8831   Mean   :2.31   Mean   :11.138  \n 3rd Qu.:2.558   3rd Qu.:1.0450   3rd Qu.:3.00   3rd Qu.:14.050  \n Max.   :4.381   Max.   :1.7300   Max.   :4.75   Max.   :23.600  \n    protein           oil       \n Min.   :33.20   Min.   :13.03  \n 1st Qu.:38.14   1st Qu.:17.97  \n Median :40.25   Median :19.82  \n Mean   :40.33   Mean   :19.92  \n 3rd Qu.:42.20   3rd Qu.:22.09  \n Max.   :48.50   Max.   :26.84  \n```\n\n\n:::\n:::\n\n\n**But we prefer using summarize from tidyverse**\n\n`Summarize()` collapses a data frame to a single or few row(s)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nexample02 |>   \n  summarize(yield_mean = mean(yield, na.rm=TRUE))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 1\n  yield_mean\n       <dbl>\n1       2.05\n```\n\n\n:::\n:::\n\n\n**Summarize by group**\n\n\n::: {.cell}\n\n```{.r .cell-code}\nunique(example02$loc)  \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Lawes\"      \"Brookstead\" \"Nambour\"    \"RedlandBay\"\n```\n\n\n:::\n\n```{.r .cell-code}\nexample02 |>   group_by(loc) |>  \n  summarise(yield_loc = mean(yield, na.rm = TRUE)) \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 × 2\n  loc        yield_loc\n  <chr>          <dbl>\n1 Brookstead      2.01\n2 Lawes           2.37\n3 Nambour         2.09\n4 RedlandBay      1.72\n```\n\n\n:::\n\n```{.r .cell-code}\nexample02 |>   group_by(loc, year) |>  \n  summarise(yield_loc = mean(yield, na.rm = TRUE)) \n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n`summarise()` has grouped output by 'loc'. You can override using the `.groups`\nargument.\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 8 × 3\n# Groups:   loc [4]\n  loc         year yield_loc\n  <chr>      <dbl>     <dbl>\n1 Brookstead  1970      1.56\n2 Brookstead  1971      2.46\n3 Lawes       1970      2.24\n4 Lawes       1971      2.51\n5 Nambour     1970      1.89\n6 Nambour     1971      2.30\n7 RedlandBay  1970      1.64\n8 RedlandBay  1971      1.79\n```\n\n\n:::\n\n```{.r .cell-code}\nexample02 |>   group_by(gen) |>   \n  summarise(yield = mean(yield, na.rm = TRUE)) |>    \n  arrange(desc(yield))  \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 58 × 2\n   gen   yield\n   <chr> <dbl>\n 1 G49    3.22\n 2 G48    3.05\n 3 G50    2.97\n 4 G45    2.91\n 5 G57    2.89\n 6 G53    2.87\n 7 G56    2.82\n 8 G47    2.66\n 9 G55    2.53\n10 G04    2.44\n# ℹ 48 more rows\n```\n\n\n:::\n\n```{.r .cell-code}\nexample02 |>  \n  group_by(gen, loc) |>  \n  summarise(yield = mean(yield, na.rm = TRUE)) |>  \n  arrange(desc(yield))\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n`summarise()` has grouped output by 'gen'. You can override using the `.groups`\nargument.\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 232 × 3\n# Groups:   gen [58]\n   gen   loc        yield\n   <chr> <chr>      <dbl>\n 1 G48   Lawes       3.98\n 2 G49   RedlandBay  3.81\n 3 G45   Lawes       3.54\n 4 G50   Brookstead  3.39\n 5 G53   Brookstead  3.36\n 6 G49   Brookstead  3.35\n 7 G45   Brookstead  3.27\n 8 G57   Lawes       3.26\n 9 G50   Lawes       3.24\n10 G57   Brookstead  3.20\n# ℹ 222 more rows\n```\n\n\n:::\n:::\n\n\n### **Missing values**\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmissing_dat <- read_csv(\"Example-02-missing.csv\")  \n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nRows: 464 Columns: 10\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (3): env, loc, gen\ndbl (7): year, yield, height, lodging, size, protein, oil\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n```\n\n\n:::\n\n```{.r .cell-code}\nmean(missing_dat$yield, na.rm = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2.044911\n```\n\n\n:::\n:::\n\n\n**How to get the missing data if any**\n\n\n::: {.cell}\n\n```{.r .cell-code}\nexample02.missing <- read_csv(\"Example-02-missing.csv\")\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nRows: 464 Columns: 10\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (3): env, loc, gen\ndbl (7): year, yield, height, lodging, size, protein, oil\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n```\n\n\n:::\n\n```{.r .cell-code}\nmissing_dat |>  \n  group_by(loc) |>    \n  summarize(Nmissing=sum(is.na(yield))) \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 × 2\n  loc        Nmissing\n  <chr>         <int>\n1 Brookstead        0\n2 Lawes             2\n3 Nambour           1\n4 RedlandBay        0\n```\n\n\n:::\n:::\n\n\nSelect the obs with a missing yield\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmissing_dat |>    \n  filter(is.na(yield))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 10\n  env   loc      year gen   yield height lodging  size protein   oil\n  <chr> <chr>   <dbl> <chr> <dbl>  <dbl>   <dbl> <dbl>   <dbl> <dbl>\n1 L70   Lawes    1970 G29      NA  1.13     4     9.65    39.4  19.9\n2 L70   Lawes    1970 G32      NA  1.73     3.5   9.65    42.2  18.7\n3 N70   Nambour  1970 G06      NA  0.595    1.25 12.0     35.1  23.2\n```\n\n\n:::\n:::\n\n\nThe total number of obs is 464\n\n\n::: {.cell}\n\n```{.r .cell-code}\nexample02.missing |>   \n  filter(!is.na(yield)) \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 461 × 10\n   env   loc    year gen   yield height lodging  size protein   oil\n   <chr> <chr> <dbl> <chr> <dbl>  <dbl>   <dbl> <dbl>   <dbl> <dbl>\n 1 L70   Lawes  1970 G01    2.39  1.44     4.25  8.45    36.7  20.9\n 2 L70   Lawes  1970 G02    2.28  1.45     4.25  9.95    37.6  20.7\n 3 L70   Lawes  1970 G03    2.57  1.46     3.75 10.8     37.8  21.3\n 4 L70   Lawes  1970 G04    2.88  1.26     3.5  10.0     38.4  22.0\n 5 L70   Lawes  1970 G05    2.39  1.34     3.5  11       37.5  22.1\n 6 L70   Lawes  1970 G06    2.41  1.36     4    11.8     38.2  21.2\n 7 L70   Lawes  1970 G07    2.70  1.3      3    11.8     37.4  21.7\n 8 L70   Lawes  1970 G08    2.46  0.955    3.25 10       35.2  21.1\n 9 L70   Lawes  1970 G09    2.57  1.03     3    11.2     35.9  21.5\n10 L70   Lawes  1970 G10    2.98  1.16     3.75 10.8     39.7  20.4\n# ℹ 451 more rows\n```\n\n\n:::\n:::\n\n\n464 obs = 461 valid + 3 missing\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(is.na(example02.missing$yield))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE FALSE FALSE FALSE FALSE FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\nsum(is.na(example02.missing$yield)) \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3\n```\n\n\n:::\n:::\n\n\n### **Count**\n\nCounting the number of observations\n\n\n::: {.cell}\n\n```{.r .cell-code}\nexample02 |>   \n  group_by(loc) |>  \n  summarise(new4 = n())\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 × 2\n  loc         new4\n  <chr>      <int>\n1 Brookstead   116\n2 Lawes        116\n3 Nambour      116\n4 RedlandBay   116\n```\n\n\n:::\n:::\n\n\n### **Factors**\n\nThe function as.factor() convert a variable to a factor\n\n\n::: {.cell}\n\n```{.r .cell-code}\nexample02$env <- \n  as.factor(example02$env)\n\nexample02$loc <- as.factor(example02$loc) \n\nexample02$gen <- as.factor(example02$gen) \n```\n:::\n\n\nThis is equivalent to the code below using mutate() and the pipe \\|\\>\n\n\n::: {.cell}\n\n```{.r .cell-code}\nexample02 <- example02 |>   \n  mutate(     env=factor(env),   \n              loc=factor(loc),     gen=factor(gen)   ) \n\nexample02 |>   mutate(across(c(env, loc, gen)))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 464 × 10\n   env   loc    year gen   yield height lodging  size protein   oil\n   <fct> <fct> <dbl> <fct> <dbl>  <dbl>   <dbl> <dbl>   <dbl> <dbl>\n 1 L70   Lawes  1970 G01    2.39  1.44     4.25  8.45    36.7  20.9\n 2 L70   Lawes  1970 G02    2.28  1.45     4.25  9.95    37.6  20.7\n 3 L70   Lawes  1970 G03    2.57  1.46     3.75 10.8     37.8  21.3\n 4 L70   Lawes  1970 G04    2.88  1.26     3.5  10.0     38.4  22.0\n 5 L70   Lawes  1970 G05    2.39  1.34     3.5  11       37.5  22.1\n 6 L70   Lawes  1970 G06    2.41  1.36     4    11.8     38.2  21.2\n 7 L70   Lawes  1970 G07    2.70  1.3      3    11.8     37.4  21.7\n 8 L70   Lawes  1970 G08    2.46  0.955    3.25 10       35.2  21.1\n 9 L70   Lawes  1970 G09    2.57  1.03     3    11.2     35.9  21.5\n10 L70   Lawes  1970 G10    2.98  1.16     3.75 10.8     39.7  20.4\n# ℹ 454 more rows\n```\n\n\n:::\n:::\n\n\nTo display the levels of a factor\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlevels(example02$loc)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Brookstead\" \"Lawes\"      \"Nambour\"    \"RedlandBay\"\n```\n\n\n:::\n:::\n\n\nTo get the number of levels of a factor\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnlevels(example02$env)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 8\n```\n\n\n:::\n:::\n\n\n<br><br>\n\n# [**Pivoting**]{style=\"color: #2C6D26;\"}\n\nData management is an important task during data analysis because most times, datasets do not come in the required shape for analysis and result presentation. Hence, the need for conversion of dataset tables from wide to long format, or vice versa. It is important to understand data frame intuition where variables are in columns, observations are in rows, and values are in the cell.\n\n![](images/tibble.png)\n\nThe `pivot_wider()` or `pivot_longer()` functions in R **tidyverse** package help reorganize or reshape data values into the needed layout.\n\n![](images/Pivot.jpg) <br><br>\n\n## [**Pivot Longer**]{style=\"color:#002D62;\"}\n\nA common problem is a dataset where some of the column names are not names of variables, but values of a variable. The function `pivot_longer()` transform the dataset in wide format to longer.\n\nBelow is the basic R syntax needed to transform data from a wide format to a long format:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#| eval = TRUE\n#pivot_longer(data, cols, names_to = \"xxx\", values_to = \"yyy\") #<<\n```\n:::\n\n\n-   `data`: a data frame to pivot longer\n-   `cols`: columns to pivot into long format\n-   `names_to`: a character specifying the name of the selected columns to pivot\n-   `values_to`: a character specifying the name of the cell values in the pivoted columns.\n\n## [**Example**]{style=\"color: #002D62;\"}\n\nTo illustrate how this function works, let’s import the Australia Soybean 1970 dataset.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#|, echo=TRUE\n#library(tidyverse) \ndat <- read_csv(\"australia.soybean1970.csv\") \n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nRows: 232 Columns: 7\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (3): env, loc, gen\ndbl (4): year, yield, height, lodging\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n```\n\n\n:::\n:::\n\n\nWe have a data frame with 7 variables (env, loc, year, gen, yield, height, and lodging) and 232 observations. The data frame is stored under an object named **dat**\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#|echo=TRUE\n#| results=\"tiny\"\n\ndat\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 232 × 7\n   env   loc    year gen   yield height lodging\n   <chr> <chr> <dbl> <chr> <dbl>  <dbl>   <dbl>\n 1 L70   Lawes  1970 G01    2.39  1.44     4.25\n 2 L70   Lawes  1970 G02    2.28  1.45     4.25\n 3 L70   Lawes  1970 G03    2.57  1.46     3.75\n 4 L70   Lawes  1970 G04    2.88  1.26     3.5 \n 5 L70   Lawes  1970 G05    2.39  1.34     3.5 \n 6 L70   Lawes  1970 G06    2.41  1.36     4   \n 7 L70   Lawes  1970 G07    2.70  1.3      3   \n 8 L70   Lawes  1970 G08    2.46  0.955    3.25\n 9 L70   Lawes  1970 G09    2.57  1.03     3   \n10 L70   Lawes  1970 G10    2.98  1.16     3.75\n# ℹ 222 more rows\n```\n\n\n:::\n:::\n\n\nAs you can see, the dataset is already in wide format as seen from the previous slide. To transform the dataset into a long format, we use the function `pivot_longer`\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#|echo=TRUE \n#|tidy=FALSE\ndat_longer <- dat |>  \n  pivot_longer(yield:lodging, names_to = \"trait\", values_to = \"values\") \n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n#|echo=TRUE\n#| results=\"tiny\"\ndat_longer\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 696 × 6\n   env   loc    year gen   trait   values\n   <chr> <chr> <dbl> <chr> <chr>    <dbl>\n 1 L70   Lawes  1970 G01   yield     2.39\n 2 L70   Lawes  1970 G01   height    1.44\n 3 L70   Lawes  1970 G01   lodging   4.25\n 4 L70   Lawes  1970 G02   yield     2.28\n 5 L70   Lawes  1970 G02   height    1.45\n 6 L70   Lawes  1970 G02   lodging   4.25\n 7 L70   Lawes  1970 G03   yield     2.57\n 8 L70   Lawes  1970 G03   height    1.46\n 9 L70   Lawes  1970 G03   lodging   3.75\n10 L70   Lawes  1970 G04   yield     2.88\n# ℹ 686 more rows\n```\n\n\n:::\n:::\n\n\n<br><br>\n\n## [**Pivot Wider**]{style=\"color: #2C6D26;\"}\n\nThe function `pivot_wider()` is the opposite of the `pivot_longer()` function. It transforms the dataset from long format to wider. Below is the basic R syntax needed to transform data from a wide format to a long format:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#|eval = FALSE\n\n#pivot_wider(data, names_from = \"xxx\", values_from = \"yyy\") #<<\n```\n:::\n\n\n-   `data`: a data frame to pivot wider\n-   `names_from`: the name of the output column\n-   `values_from`: the name of the column to get the cell values from\n\n## [**Example**]{style=\"color: #002D62;\"}\n\nTo transform the dataset into a wide format, we use the function `pivot_wider()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#|echo=TRUE\n#|results=\"tiny\"\nlibrary(tidyverse) \ndat <- read_csv(\"Longer.csv\") \n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nRows: 696 Columns: 6\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (4): env, loc, gen, trait\ndbl (2): year, values\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n#|echo=TRUE\n#|results=\"tiny\"\n\ndat\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 696 × 6\n   env   loc    year gen   trait   values\n   <chr> <chr> <dbl> <chr> <chr>    <dbl>\n 1 L70   Lawes  1970 G01   yield     2.39\n 2 L70   Lawes  1970 G01   height    1.44\n 3 L70   Lawes  1970 G01   lodging   4.25\n 4 L70   Lawes  1970 G02   yield     2.28\n 5 L70   Lawes  1970 G02   height    1.45\n 6 L70   Lawes  1970 G02   lodging   4.25\n 7 L70   Lawes  1970 G03   yield     2.57\n 8 L70   Lawes  1970 G03   height    1.46\n 9 L70   Lawes  1970 G03   lodging   3.75\n10 L70   Lawes  1970 G04   yield     2.88\n# ℹ 686 more rows\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n#|echo=TRUE\n#|tidy=FALSE\ndat_wider <- dat |>   pivot_wider(names_from = \"trait\", values_from = \"values\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n#|echo=TRUE\n#|results=\"tiny\"\n\ndat_wider\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 232 × 7\n   env   loc    year gen   yield height lodging\n   <chr> <chr> <dbl> <chr> <dbl>  <dbl>   <dbl>\n 1 L70   Lawes  1970 G01    2.39  1.44     4.25\n 2 L70   Lawes  1970 G02    2.28  1.45     4.25\n 3 L70   Lawes  1970 G03    2.57  1.46     3.75\n 4 L70   Lawes  1970 G04    2.88  1.26     3.5 \n 5 L70   Lawes  1970 G05    2.39  1.34     3.5 \n 6 L70   Lawes  1970 G06    2.41  1.36     4   \n 7 L70   Lawes  1970 G07    2.70  1.3      3   \n 8 L70   Lawes  1970 G08    2.46  0.955    3.25\n 9 L70   Lawes  1970 G09    2.57  1.03     3   \n10 L70   Lawes  1970 G10    2.98  1.16     3.75\n# ℹ 222 more rows\n```\n\n\n:::\n:::\n\n\n<br><br>\n\n# [**Combining Tables**]{style=\"color: #2C6D26;\"}\n\nSo far we have seen how tidy data can be reshaped. However, there are occasions when dataset comes from different data sources and we need to combine them together before we proceed further to analysis or result presentation. The `dplyr` in R **tidyverse** package offers different mutating join functions to combine datasets together. A mutating join function allows you to combine variables from two tables by matching observations by key variable(s), then copy variables from one table to another.\n\nThere are four common mutating joins: `left_join`, `right_join`, `inner_join`, and `full_join`. They all have the same arguments but return different tables, *df1* and *df2* are a pair of data frames to join, and *by* is a unique character vector variable(s) to join the data frames by.\n\n## [**Left Join**]{style=\"color: #002D62;\"}\n\n`left_join(df1, df2, by)`\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#join matching values from df2 to df1 \n```\n:::\n\n\n![](images/left1.jpg){width=\"30%\"}\n\n![](images/left2.jpg){width=\"30%\"}\n\nA left join in R is a kind of database join that joins two data frames together by their columns using a shared key. Only the matching rows from the right data frame are included in the result of a left join, which contains all of the rows from the left data frame. NA values are entered for each column in the corresponding data frame if there is no match.\\\n\\\n**Example** To demonstrate how these mutating joins work, let’s import the pair of data frames needed.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#|echo=TRUE\nlibrary(readxl) \ndat1 <- read_excel(\"df.combine.xlsx\", sheet=\"df1\") \ndat2 <- read_excel(\"df.combine.xlsx\", sheet=\"df2\")\n```\n:::\n\n\n**dat1** has 15 observations with five variables:gen, yield, height, size, and protein.\n\n**dat2** has 15 observations with two variables:gen, oil.\n\nDisplay the observations in dat1\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#|echo=TRUE\n#|results=\"tiny\"\n\ndat1\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 15 × 5\n   gen   yield height  size protein\n   <chr> <dbl>  <dbl> <dbl>   <dbl>\n 1 G01    2.79  0.97   8.35    39.4\n 2 G02    2.62  0.785  9.75    40.6\n 3 G03    2.48  0.955 11.4     37.4\n 4 G04    2.92  0.76  11.1     36.9\n 5 G05    2.14  0.76  11.9     38.7\n 6 G06    2.86  0.65  12.2     38.1\n 7 G07    2.97  0.8   11.2     37.4\n 8 G08    1.65  0.9   11.8     36.6\n 9 G09    3.1   0.825 12.2     37.1\n10 G10    3.00  0.785 12.0     37.8\n11 G11    1.90  0.875  7.4     43.4\n12 G12    1.64  1.16   7.45    44.4\n13 G13    1.97  1.08   8.25    42.2\n14 G14    2.45  0.865  7.65    38.4\n15 G15    2.63  0.675  9.05    40.7\n```\n\n\n:::\n:::\n\n\nDisplay the observations in dat2\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#|echo=TRUE\n#|results=\"tiny\"\ndat2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 15 × 5\n   gen   yield height  size   oil\n   <chr> <dbl>  <dbl> <dbl> <dbl>\n 1 G01    2.39  1.44   8.45  20.9\n 2 G02    2.28  1.45   9.95  20.7\n 3 G03    2.57  1.46  10.8   21.3\n 4 G04    2.88  1.26  10.0   22.0\n 5 G05    2.39  1.34  11     22.1\n 6 G06    2.41  1.36  11.8   21.2\n 7 G07    2.70  1.3   11.8   21.7\n 8 G08    2.46  0.955 10     21.1\n 9 G09    2.57  1.03  11.2   21.5\n10 G10    2.98  1.16  10.8   20.4\n11 G16    1.66  1.42   6.95  19.1\n12 G17    1.96  1.44   8.35  18.7\n13 G18    1.47  1.58   9.3   19.2\n14 G19    2.72  1.33   8.25  20.8\n15 G20    2.22  1.37   9.3   20.7\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n#|echo=TRUE\n#|results=\"tiny\"\n\n# Left join \ndf_left <- left_join(dat1, dat2)   \n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nJoining with `by = join_by(gen, yield, height, size)`\n```\n\n\n:::\n\n```{.r .cell-code}\ndf_left\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 15 × 6\n   gen   yield height  size protein   oil\n   <chr> <dbl>  <dbl> <dbl>   <dbl> <dbl>\n 1 G01    2.79  0.97   8.35    39.4    NA\n 2 G02    2.62  0.785  9.75    40.6    NA\n 3 G03    2.48  0.955 11.4     37.4    NA\n 4 G04    2.92  0.76  11.1     36.9    NA\n 5 G05    2.14  0.76  11.9     38.7    NA\n 6 G06    2.86  0.65  12.2     38.1    NA\n 7 G07    2.97  0.8   11.2     37.4    NA\n 8 G08    1.65  0.9   11.8     36.6    NA\n 9 G09    3.1   0.825 12.2     37.1    NA\n10 G10    3.00  0.785 12.0     37.8    NA\n11 G11    1.90  0.875  7.4     43.4    NA\n12 G12    1.64  1.16   7.45    44.4    NA\n13 G13    1.97  1.08   8.25    42.2    NA\n14 G14    2.45  0.865  7.65    38.4    NA\n15 G15    2.63  0.675  9.05    40.7    NA\n```\n\n\n:::\n:::\n\n\n-   The code performs a left join on `dat1` and `dat2`, resulting in a new data frame `df_left` that contains all rows from the left data frame (`dat1`) along with matching rows from `dat2`. Rows in `dat1` without a corresponding match in `dat2` will have `NA` in their resulting columns for data from `dat2`.\n\n    <br><br>\n\n## [**Right Join**]{style=\"color: #002D62;\"}\n\n`right_join(df1, df2, by)`\n\n```{r} #join matching values from df2 to df1}\n```\n\n![](images/right1.jpg){width=\"30%\"}\n\n![](images/right2.jpg){width=\"30%\"}\n\nA right join is a type of database join that combines two data frames based on a common key, similar to a left join but with a focus on retaining all the rows from the right data frame. When performing a right join, all rows from the right data frame are included in the result, and only the matching rows from the left data frame are included. If there is no match, the corresponding columns of the left data frame will be filled with `NA` values\n\n**Example**\n\nContinuing with the previous data,\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#|echo=TRUE\n#|results=\"tiny\"\n# Right join \ndf_right <- right_join(dat1, dat2)  \n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nJoining with `by = join_by(gen, yield, height, size)`\n```\n\n\n:::\n\n```{.r .cell-code}\ndf_right\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 15 × 6\n   gen   yield height  size protein   oil\n   <chr> <dbl>  <dbl> <dbl>   <dbl> <dbl>\n 1 G01    2.39  1.44   8.45      NA  20.9\n 2 G02    2.28  1.45   9.95      NA  20.7\n 3 G03    2.57  1.46  10.8       NA  21.3\n 4 G04    2.88  1.26  10.0       NA  22.0\n 5 G05    2.39  1.34  11         NA  22.1\n 6 G06    2.41  1.36  11.8       NA  21.2\n 7 G07    2.70  1.3   11.8       NA  21.7\n 8 G08    2.46  0.955 10         NA  21.1\n 9 G09    2.57  1.03  11.2       NA  21.5\n10 G10    2.98  1.16  10.8       NA  20.4\n11 G16    1.66  1.42   6.95      NA  19.1\n12 G17    1.96  1.44   8.35      NA  18.7\n13 G18    1.47  1.58   9.3       NA  19.2\n14 G19    2.72  1.33   8.25      NA  20.8\n15 G20    2.22  1.37   9.3       NA  20.7\n```\n\n\n:::\n:::\n\n\nThe right join operation retains all rows from the right data frame (`dat2`) and only those rows from the left data frame (`dat1`) that match based on the specified keys. If there are entries in `dat2` without corresponding matches in `dat1`, the output will show `NA` in place of those unmatched entries from `dat1`\n\n<br><br>\n\n## [**Inner Join**]{style=\"color: #002D62;\"}\n\n`inner_join(df1, df2, by)`\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#join values from df2 to df1 and retain only matching rows\n```\n:::\n\n\n![](images/inner1.jpg){width=\"30%\"}\n\n![](images/inner2.jpg){width=\"30%\"}\n\nAn inner join is a type of database join that combines two data frames (or tables) based on a common key or keys, returning only those rows where there is a match in both data frames. In other words, an inner join retrieves the intersection of the two dataset\n\n**Example**\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#|echo=TRUE\n#|results=\"tiny\"\n# Inner join\ndf_inner <- inner_join(dat1, dat2)   \n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nJoining with `by = join_by(gen, yield, height, size)`\n```\n\n\n:::\n\n```{.r .cell-code}\ndf_inner\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 0 × 6\n# ℹ 6 variables: gen <chr>, yield <dbl>, height <dbl>, size <dbl>,\n#   protein <dbl>, oil <dbl>\n```\n\n\n:::\n:::\n\n\nThe resulting data frame (`df_inner`) contains only those rows where there are matching values in the `id` column of both `dat1` and `dat2`\n\n<br><br>\n\n## [**Full join**]{style=\"color: #002D62;\"}\n\n`full_join(df1, df2, by)`\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#join values from df2 to df1 and retain all rows, all values \n```\n:::\n\n\n![](images/full1.jpg){width=\"30%\"}\n\n![](images/full2.jpg){width=\"30%\"}\n\nA full join (or full outer join) is a type of database join that combines the results of both left and right joins. This means that a full join returns all the rows from both data frames (or tables), regardless of whether there is a match between them. If a row in one data frame does not have a corresponding match in the other, the result will contain `NA` (or missing values) for the columns of the unmatched row from the other data frame.\n\n**Example**\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#|echo=TRUE\n#|results=\"tiny\"\n# Full join \ndf_full <- full_join(dat1, dat2)  \n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nJoining with `by = join_by(gen, yield, height, size)`\n```\n\n\n:::\n\n```{.r .cell-code}\ndf_full\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 30 × 6\n   gen   yield height  size protein   oil\n   <chr> <dbl>  <dbl> <dbl>   <dbl> <dbl>\n 1 G01    2.79  0.97   8.35    39.4    NA\n 2 G02    2.62  0.785  9.75    40.6    NA\n 3 G03    2.48  0.955 11.4     37.4    NA\n 4 G04    2.92  0.76  11.1     36.9    NA\n 5 G05    2.14  0.76  11.9     38.7    NA\n 6 G06    2.86  0.65  12.2     38.1    NA\n 7 G07    2.97  0.8   11.2     37.4    NA\n 8 G08    1.65  0.9   11.8     36.6    NA\n 9 G09    3.1   0.825 12.2     37.1    NA\n10 G10    3.00  0.785 12.0     37.8    NA\n# ℹ 20 more rows\n```\n\n\n:::\n:::\n\n\nThe code `df_full <- full_join(dat1, dat2)` effectively creates a new data frame that combines data from `dat1` and `dat2`, ensuring that all records are retained, either matched or unmatched. This type of join is particularly useful in exploratory data analysis and situations where preserving all relevant data is critical for further analysis and interpretation.\n\n<br><br>\n\n# [**Creating Groups**]{style=\"color: #2C6D26;\"}\n\nData wrangling in R sometimes requires modification or creating a new variable based on certain possible conditions during data analysis.\n\nIt is possible to create new variables with the mutate() function in the tidyverse package.\n\nThe `case_when()` function allows you to vectorize multiple `if_else` statements, i.e. you test condition-1, and then output output-value-1 if the condition-1 is true, then test condition-2, and output output-value-2 if condition-2 is true, the logical statements continue until you specify a value to output if none of the conditions were true.\n\nHowever, if we are interested in creating a new variable within a dataframe based on certain conditions with some `if-elif-else` style logic, then the case_when() function is used with the `mutate()` function, both are in the **tidyverse** package.\n\nTo illustrate the description in the previous slide, let's consider the image below\n\n![](images/case_when.jpg)\n\nThe `TRUE~` is equivalent to the `‘else’` in the `‘if-else’` statement.\n\nIt is important to note that the conditions are evaluated in order, therefore one must proceed from the most specific to the most general condition.\n\nLet’s demonstrate how `case_when` works with these examples using the Australia Soybean 1970 dataset.\n\nWe are going to create four lodging categories such as \\>=1 = 'No Lodging', \\>=1.5 = 'Mild Lodging', \\>=2.5 = 'Moderate Lodging', and \\>=3.5 = 'Heavy Lodging'.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#|echo=TRUE\n\ndat <- read_csv(\"australia.soybean1970.csv\") \n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nRows: 232 Columns: 7\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (3): env, loc, gen\ndbl (4): year, yield, height, lodging\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n```\n\n\n:::\n\n```{.r .cell-code}\ndat\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 232 × 7\n   env   loc    year gen   yield height lodging\n   <chr> <chr> <dbl> <chr> <dbl>  <dbl>   <dbl>\n 1 L70   Lawes  1970 G01    2.39  1.44     4.25\n 2 L70   Lawes  1970 G02    2.28  1.45     4.25\n 3 L70   Lawes  1970 G03    2.57  1.46     3.75\n 4 L70   Lawes  1970 G04    2.88  1.26     3.5 \n 5 L70   Lawes  1970 G05    2.39  1.34     3.5 \n 6 L70   Lawes  1970 G06    2.41  1.36     4   \n 7 L70   Lawes  1970 G07    2.70  1.3      3   \n 8 L70   Lawes  1970 G08    2.46  0.955    3.25\n 9 L70   Lawes  1970 G09    2.57  1.03     3   \n10 L70   Lawes  1970 G10    2.98  1.16     3.75\n# ℹ 222 more rows\n```\n\n\n:::\n:::\n\n\n<br><br>\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#|echo=TRUE\n#|tidy=FALSE\ndat_new <- dat |>      \t\tmutate(         \t\t\tlodging_grp = case_when(                                       lodging >= 3.5 ~ \"Heavy Lodging\",                                 \t\t  lodging >= 2.5 ~ \"Moderate Lodging\",                                \t\t  \tlodging >= 1.5 ~ \"Mild Lodging\",                                 \t\t  lodging >= 1 ~ \"No Lodging\",                                 \t\t \t\t       TRUE ~ \"NA\")  \t\t\t ) \n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n#|echo=TRUE \n#|results=\"tiny\"\ndat_new \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 232 × 8\n   env   loc    year gen   yield height lodging lodging_grp     \n   <chr> <chr> <dbl> <chr> <dbl>  <dbl>   <dbl> <chr>           \n 1 L70   Lawes  1970 G01    2.39  1.44     4.25 Heavy Lodging   \n 2 L70   Lawes  1970 G02    2.28  1.45     4.25 Heavy Lodging   \n 3 L70   Lawes  1970 G03    2.57  1.46     3.75 Heavy Lodging   \n 4 L70   Lawes  1970 G04    2.88  1.26     3.5  Heavy Lodging   \n 5 L70   Lawes  1970 G05    2.39  1.34     3.5  Heavy Lodging   \n 6 L70   Lawes  1970 G06    2.41  1.36     4    Heavy Lodging   \n 7 L70   Lawes  1970 G07    2.70  1.3      3    Moderate Lodging\n 8 L70   Lawes  1970 G08    2.46  0.955    3.25 Moderate Lodging\n 9 L70   Lawes  1970 G09    2.57  1.03     3    Moderate Lodging\n10 L70   Lawes  1970 G10    2.98  1.16     3.75 Heavy Lodging   \n# ℹ 222 more rows\n```\n\n\n:::\n:::\n\n\nAlso, we may be interested in creating a new variable from the existing categorical variable.\n\nLet’s use the new data set `dat_new` to demonstrate this process using `mutate` and `case_when` functions and introduce the `IN` operator `%in%` i.e. We create two lodging categories such that `'No Lodging'` and `'Mild Lodging'` will be `\"No Lodging\"`, and `'Moderate Lodging'` and `'Heavy Lodging'` will be `\"Lodging\"`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#|echo=TRUE\n#|tidy=FALSE\n\ndat_new <- dat_new |>           mutate(           lodging_grp2 = case_when(           lodging_grp %in% c(\"Heavy Lodging\",\"Moderate Lodging\")  ~ \"Lodging\",           lodging_grp %in% c(\"No Lodging\", \"Mild Lodging\") ~ \"No Lodging\",                                                     TRUE   ~ \"NA\")   \t\t)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n#|echo=TRUE \n#|results=\"tiny\"\ndat_new \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 232 × 9\n   env   loc    year gen   yield height lodging lodging_grp      lodging_grp2\n   <chr> <chr> <dbl> <chr> <dbl>  <dbl>   <dbl> <chr>            <chr>       \n 1 L70   Lawes  1970 G01    2.39  1.44     4.25 Heavy Lodging    Lodging     \n 2 L70   Lawes  1970 G02    2.28  1.45     4.25 Heavy Lodging    Lodging     \n 3 L70   Lawes  1970 G03    2.57  1.46     3.75 Heavy Lodging    Lodging     \n 4 L70   Lawes  1970 G04    2.88  1.26     3.5  Heavy Lodging    Lodging     \n 5 L70   Lawes  1970 G05    2.39  1.34     3.5  Heavy Lodging    Lodging     \n 6 L70   Lawes  1970 G06    2.41  1.36     4    Heavy Lodging    Lodging     \n 7 L70   Lawes  1970 G07    2.70  1.3      3    Moderate Lodging Lodging     \n 8 L70   Lawes  1970 G08    2.46  0.955    3.25 Moderate Lodging Lodging     \n 9 L70   Lawes  1970 G09    2.57  1.03     3    Moderate Lodging Lodging     \n10 L70   Lawes  1970 G10    2.98  1.16     3.75 Heavy Lodging    Lodging     \n# ℹ 222 more rows\n```\n\n\n:::\n:::\n\n\n<br><br>\n\n# [**Strings**]{style=\"color: #2C6D26;\"}\n\nAs we all know that data comes in different formats, numeric or non-numeric (text/string) data format. Data wrangling of non-numeric data sometimes requires splitting of the cell into multiple individual cells or combining multiple cells into a single cell before analysis.\n\nThere are some functions in the tidyverse package used for this purpose such as `unite()`, `separate()`, and `str_sub()`.\n\n-   `unite()`: collapse cells across several columns into a single column.\n\n-   `separate()`: separate each cell in a column into several columns.\n\n-   `str_sub()`: extract a substring from a character vector.\n\nLet’s use a fictitious data set called **BadData** to demonstrate how these functions work.\n\nThe data set has seven (7) variables: Gen: A combination of location, genotype, and replication, Year: Year of trials, Traits: Measured traits (Trait1 – Trait5)\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#|echo=TRUE \n#|results=\"tiny\"\n\ndat <- read_csv(\"BadData.csv\")\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nRows: 360 Columns: 7\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (1): Gen\ndbl (6): Year, Trait1, Trait2, Trait3, Trait4, Trait5\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n```\n\n\n:::\n\n```{.r .cell-code}\ndat\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 360 × 7\n   Gen       Year Trait1 Trait2 Trait3 Trait4 Trait5\n   <chr>    <dbl>  <dbl>  <dbl>  <dbl>  <dbl>  <dbl>\n 1 IBG10-1   2020     12     12     58     63     85\n 2 IBG10-2   2020      9      9     62     67     96\n 3 IBG10-3   2020     12     12     56     63     96\n 4 IBG11-1   2020     10     10     56     60     95\n 5 IBG11-2   2020      9      9     56     60    102\n 6 IBG11-3   2020     10     10     57     60     97\n 7 IBG12-1   2020     10     10     50     59     84\n 8 IBG12-2   2020     11     11     53     56     84\n 9 IBG12-3   2020     12     12     57     60     92\n10 IBG126-1  2020     11     10     51     58     84\n# ℹ 350 more rows\n```\n\n\n:::\n:::\n\n\nThe first task will be to create separate variables for location, genotype, and replication from the Gen variable.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#|echo=TRUE\n#|tidy=FALSE\ndat1 <- dat |>    separate(Gen, sep = \"-\", into = c(\"LocGen\", \"Rep\")) |>    mutate(           Location = str_sub(LocGen, 1, 2),           Gen = str_sub(LocGen, 3, 5)  \t ) |>    select(Location, Gen, Rep, Year, Trait1, Trait2, Trait3, Trait4, Trait5)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n#|echo=TRUE\n#|results=\"tiny\"\ndat1\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 360 × 9\n   Location Gen   Rep    Year Trait1 Trait2 Trait3 Trait4 Trait5\n   <chr>    <chr> <chr> <dbl>  <dbl>  <dbl>  <dbl>  <dbl>  <dbl>\n 1 IB       G10   1      2020     12     12     58     63     85\n 2 IB       G10   2      2020      9      9     62     67     96\n 3 IB       G10   3      2020     12     12     56     63     96\n 4 IB       G11   1      2020     10     10     56     60     95\n 5 IB       G11   2      2020      9      9     56     60    102\n 6 IB       G11   3      2020     10     10     57     60     97\n 7 IB       G12   1      2020     10     10     50     59     84\n 8 IB       G12   2      2020     11     11     53     56     84\n 9 IB       G12   3      2020     12     12     57     60     92\n10 IB       G12   1      2020     11     10     51     58     84\n# ℹ 350 more rows\n```\n\n\n:::\n:::\n\n\nAlso, we may be interested in creating a new variable which will be a combination of at least two variables. Suppose we want to create a variable called environment `(Env)` using the data set above by combining the Location and Year together.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#|echo=TRUE\n#|results=\"tiny\"\ndat1 <- dat1 |> unite(Location, Year, col = \"Env\", sep = \"-\") \ndat1\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 360 × 8\n   Env     Gen   Rep   Trait1 Trait2 Trait3 Trait4 Trait5\n   <chr>   <chr> <chr>  <dbl>  <dbl>  <dbl>  <dbl>  <dbl>\n 1 IB-2020 G10   1         12     12     58     63     85\n 2 IB-2020 G10   2          9      9     62     67     96\n 3 IB-2020 G10   3         12     12     56     63     96\n 4 IB-2020 G11   1         10     10     56     60     95\n 5 IB-2020 G11   2          9      9     56     60    102\n 6 IB-2020 G11   3         10     10     57     60     97\n 7 IB-2020 G12   1         10     10     50     59     84\n 8 IB-2020 G12   2         11     11     53     56     84\n 9 IB-2020 G12   3         12     12     57     60     92\n10 IB-2020 G12   1         11     10     51     58     84\n# ℹ 350 more rows\n```\n\n\n:::\n:::\n\n\n## [**Exercise**]{style=\"color: #2C6D26;\"}\n\n1.  Import Example-02.csv to R and save it to an object named example02 Display the example02 object filter the data by considering: locations Nambour and RedlandBay genotypes G01, G57, and G58, location Brookstead for the year 1970 location Lawes yield between 2 and 3 inclusive, oil greater than 22\n\n2.  Import **Example-02.csv** to R and save to an object named **example02** Create a new variable called `ENV` by combining the first three letters in `loc` and the last two digit in `year`. Categorize the `yield` values of at least 3 as `\"High\"` and other values as `\"Low\"` into a new variable called `yield_grp`. Select `ENV`, `gen`, `yield`, `yield_grp`, `height`, and `oil` and transform the dataset using appropriate variables as `traits`.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}